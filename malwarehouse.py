#!/usr/bin/env python
# encoding: utf-8
"""
malwarehouse.py

Created by Scott Roberts.
Copyright (c) 2012 TogaFoamParty Studios. All rights reserved.
"""

import datetime
import os
import pwd
import hashlib
import shutil
import re
import magic
import pydeep
import sqlite3
from optparse import OptionParser
import ConfigParser

# Malwarehouse Options
config = ConfigParser.SafeConfigParser()
config.read("malwarehouse.cfg")

option_base_dir = os.path.expanduser(config.get('settings','basedir'))

if config.get('analysis', 'yara') == 'On':
  import yara
  option_yara_rulefile = config.get('settings', 'yararules')

if config.get('analysis', 'magic') == 'On':
  import magic

if config.get('analysis', 'ssdeep') == 'On':
  import pydeep

# Setup DB
db_name = config.get('database', 'name')

class malware_sample(object):
    """malware_sample represents a piece of malware within Malwarehouse"""

    def __init__(self, sample_path, sample_source = "", sample_notes = "", yara_rules = option_yara_rulefile):
        super(malware_sample, self).__init__()

        # Analysis charactristics
        self.analysis_datetime = str(datetime.datetime.now())
        self.analysis_user = pwd.getpwuid(os.getuid())[0]
        self.analysis_sample_directory = "" # Base directory of our content
        self.analysis_sample_location = "" # Path to the malware sample
        self.analysis_summary_location = "" # Path to the analysis report

        # File characteristics
        self.file_name = sample_path.split('/')[-1]
        self.file_mimetype = self.get_mimetype(sample_path)
        self.file_size = 0

        # Hash characteristics
        self.hash_md5 = get_md5(sample_path)
        self.hash_sha256 = get_sha256(sample_path)

        if config.get('analysis', 'ssdeep')
          self.hash_ssdeep = get_ssdeep(sample_path)

        # Meta characteristics
        self.meta_tags = get_yara(sample_path, yara_rules)
        #self.meta_virustotal = [] # Impliment later
        self.meta_source = sample_source
        self.meta_notes = sample_notes

        return self

    def get_md5(self, malware_path):
        """Wrapper for the usual md5 call because it's so verbose."""

        return hashlib.md5(file(malware_path, 'r').read()).hexdigest()

    def get_sha256(self, malware_path):
        """Wrapper for the usual sha256 call because it's so verbose."""

        return hashlib.sha256(file(malware_path, 'r').read()).hexdigest()

    def get_ssdeep(self, malware_path):
        """Wrapper for the usual pyssdeep call because it's so verbose."""

        return "Not yet implimented"

    def get_mimetype(self, malware_path):
        """Finds the standard mimetype for file and returns type name."""

        mime = magic.Magic(mime=True)
        return mime.from_file(malware_path)


    def get_yara(self, malware_path):
        """Checks malware against a Yara ruleset and returns a dictionary of matched rules."""
        tags = []

        try:
            import yara
            rules = yara.compile(filepath=yara_rules, includes=True)
            yara_tags = rules.match(malware_path)

            for tag in yara_tags:
                tags.append(str(tag))

        except ImportError:
            raise
        except yara.Error as e:
            print("Yara signature file doesn't exist.")
            tags = []
        except:
            raise

        return tags

    # def tagger(self):
    #     pass

    def summary(self):
        return "- %s (%s) - %s" % (self.file_name, self.meta_source, self.hash_md5)

    def details(self):
        """Prints an easy to read summary of the malware."""

        details =  " Analysis ".center(50, "=")
        details += "datetime:".ljust(25) + "%s\n" % (report_json['datetime'])

        details += " File ".center(50, "=")
        details += "sample name:".ljust(25) + "%s\n" % (report_json['name'])
        details += "mimetype:".ljust(25) + "%s\n" % (report_json['mimetype'])
        details += "size:".ljust(25) + "%s\n" % (report_json['size'])

        details += " Hashes ".center(50, "=")
        details += "md5:".ljust(26) + "%s\n" % (report_json['md5'])
        details += "sha256:".ljust(26) + "%s\n" % (report_json['sha256'])

        details += " Meta ".center(50, "=")
        details += "tags:".ljust(26) + "%s\n" % (report_json['tags'])
        details += "source:".ljust(26) + "%s\n" % (report_json['source'])

        details += " Meta ".center(50, "=")
        details += "notes:".ljust(25) + "%s" % (report_json["notes"])
        details += "\n"
        details += "sample directory: %s" % option_base_dir + report_json['sha256']

        return details

    def __json__(self):
        print "JSON would have been returned."
        pass

    def __str__(self):
        return self.summary()

def check_prelim():
  """Initial setup code. Eventually this will set options."""
  print "\n\n"
  db_path = option_base_dir + '/' + db_name
  dir_path = option_base_dir

  print "db_path = %s" % (db_path)
  print "dir_path = %s" % (dir_path)

  if not os.path.exists(dir_path):
    print "[ERROR] Base directory %s doesn't exist. Creating it..." % (dir_path)
    os.makedirs(dir_path)

  if not os.path.exists(db_path):
    print "[ERROR] Database %s doesn't exist. Creating it..." % (db_path)

    conn = sqlite3.connect(db_path)
    c = conn.cursor()

    # Create table
    c.execute('''CREATE TABLE IF NOT EXISTS malwarehouse_index (datetime text, name text, mimetype text, tags text, size integer, md5 text, sha256 text, source text, notes text)''')

    # Save (commit) the changes
    conn.commit()

    # We can also close the cursor if we are done with it
    c.close()

  return True

def create_db():
    pass

# create, read, update, delete
def create_sample_db(sample_path):
     """Load information about the sample into the index DB."""

    #conn = sqlite3.connect(option_base_dir + "malwarehouse.db")
    #c = conn.cursor()

    # Insert a row of data
    #c.execute("INSERT INTO malwarehouse_index VALUES (\"%s\", \"%s\", \"%s\", \"%s\", \"%d\", \"%s\", \"%s\", \"%s\", \"%s\")" % (report_json['datetime'], report_json['name'], report_json['mimetype'], report_json['tags'], report_json['size'], report_json['md5'], report_json['sha256'], report_json['source'], report_json['notes']))

    # Save (commit) the changes
    #conn.commit()

    # We can also close the cursor if we are done with it
    #c.close()

    #print "Sample %s loaded..." % report_json['name']

    return True

def create_sample_filesystem():
  """Creates a directory to store the malware and summary."""
  print "Loading Malware %s" % malware_path

  sample_dir = "%s%s" % (option_base_dir, report_json['sha256'])

  if not os.path.exists(sample_dir):
    print "Creating %s" % (sample_dir)
    os.makedirs(sample_dir)

  # Sets up whether or not the file gets moved after being imported
  if config.get('settings', 'delete') = 'On'
    shutil.move(malware_path, sample_dir)
  else:
    shutil.copyfile(malware_path, sample_dir)

  with open(sample_dir + '/summary.txt', 'w') as text_file:
    text_file.write(details(report_json))

  return True

def read_sample_db():
    pass

def read_sample_filesystem():
    pass

def update_sample_db():
    pass

def update_sample_filesystem():
    pass

def delete_sample_db():
    pass

def delete_sample_filesystem():
    pass

def malware_loader(report_json, malware_path):
  load_db(report_json)
  load_directory(report_json, malware_path)

def parse_sqlite_result(unparsed):
    "Takes the results from a SQLite query and parses it as a dictionary."

    return {'datetime': unparsed[0], 'name': unparsed[1], 'mimetype': unparsed[2], 'tags': unparsed[3], 'size': unparsed[4], 'md5': unparsed[5], 'sha256': unparsed[6], 'source': unparsed[7], 'notes': unparsed[8]}

def find_sample(find_string):

    conn = sqlite3.connect(option_base_dir + "malwarehouse.db")
    c = conn.cursor()

    if re.findall(r"^([a-fA-F\d]{64})$", find_string):
        #print "\nResults for sha256: %s" % find_string
        c.execute("SELECT * FROM malwarehouse_index WHERE sha256 = ?", (find_string,))
    elif re.findall(r"^([a-fA-F\d]{32})$", find_string):
        #print "\nResults for md5: %s" % find_string
        c.execute("SELECT * FROM malwarehouse_index WHERE md5 = ?", (find_string,))
    else:
        #print "\nResults for file name: %s" % find_string
        c.execute("SELECT * FROM malwarehouse_index WHERE name = ?", (find_string,))

    data=c.fetchall()

    if data is None:
        print('There is no component named %s'%find_string)
        return False
    else:
        print "\nResults:"
        for result in data:
            print summary(parse_sqlite_result(result))
        return True

def recent(quanity='5'):
    """Returns a summary of the last n (default: n = 5) pieces of malware."""
    conn = sqlite3.connect(option_base_dir + "malwarehouse.db")
    c = conn.cursor()

    try:
        float(quanity)
    except:
        raise ValueError

    c.execute("SELECT DISTINCT * FROM malwarehouse_index ORDER BY datetime DESC LIMIT %s;" % quanity)
    data = c.fetchall()

    print "\n%s Most Recent Samples:" % quanity
    for result in data:
        print summary(parse_sqlite_result(result))

    return True

def run():
    if not check_prelim():
        print "[ERROR] Initial setup unable to complete. Exiting..."
        return False

    try:
        with open(malware_path) as f: pass
    except IOError as e:
        parser.error("You specified an invalid malware target path.")
        return False

    malware_definition = {
        "datetime": "", #calculated
        "name": "", #autodetected
        "tags": "",
        "size": "", #calculated
        "md5": "", #calculated
        "sha256": "", #calculated
        "mimetype": "", #calculated
        "source": "",
        "notes": "",
    }

    #Parsing Custom Options
    malware_definition["source"] = source
    malware_definition["tags"] = tags
    malware_definition["notes"] = notes

    #Parsing Automatically Generated Options
    malware_definition["name"] = malware_path.split('/')[-1]
    malware_definition["datetime"] = str(datetime.datetime.now())
    malware_definition["size"] = os.stat(malware_path).st_size
    malware_definition["md5"] = get_md5(malware_path)
    malware_definition["sha256"] = get_sha256(malware_path)
    malware_definition["mimetype"] = get_mime_type(malware_path)

    return malware_definition


'''
# Setup Logging
import logging
logger = logging.getLogger('default')
logger.setLevel(logging.DEBUG)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
# Setup logging to file
fh = logging.FileHandler('default.log')
fh.setLevel(logging.DEBUG)
logger.addHandler(fh)
# Setup logging to console
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)
logger.addHandler(ch)
# Setup logging to syslog
import logging.handlers
sh = logging.handlers.SysLogHandler()
sh.setLevel(logging.DEBUG)
logger.addHandler(sh)

# 'application' code
logger.debug('debug message')
logger.info('info message')
logger.warn('warn message')
logger.error('error message')
logger.critical('critical message')
'''

'''
# Setup Text Colors
class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'

    def disable(self):
        self.HEADER = ''
        self.OKBLUE = ''
        self.OKGREEN = ''
        self.WARNING = ''
        self.FAIL = ''
        self.ENDC = ''

print bcolors.OKBLUE + "Test Message" + bcolors.ENDC
'''

def foo():
    return "foo function called"

def bar():
    return "bar function called"

def main():
  check_prelim()

  parser = OptionParser(usage="usage: %prog [options] args")
  parser.add_option("-a", "--add",
                      action="store",
                      type="string",
                      dest="ADD",
                      default="",
                      help="Find a sample by name, md5, or sha256")
  parser.add_option("-s", "--source",
                      action="store",
                      type="string",
                      dest="SOURCE",
                      default=None,
                      help="Source of file")
  parser.add_option("-t", "--tags",
                      action="store",
                      type="string",
                      dest="TAGS",
                      default=None,
                      help="Any characteristics of the malware")
  parser.add_option("-n", "--notes",
                      action="store",
                      type="string",
                      dest="NOTES",
                      default="",
                      help="Notes about file")
  parser.add_option("-f", "--find",
                      action="store",
                      type="string",
                      dest="FIND",
                      default="",
                      help="Find a sample by name, md5, or sha256")
  parser.add_option("-r", "--recent",
                      action="store",
                      type="string",
                      dest="RECENT",
                      default=5,
                      help="Display the newest samples (default: 5)")
  # parser.add_option("--retag",
  #                     action="store",
  #                     type="string",
  #                     dest="FIND",
  #                     default="",
  #                     help="Find a sample by name, md5, or sha256")
  parser.add_option("-d", "--delete",
                      action="store",
                      type="string",
                      dest="DELETE",
                      default="",
                      help="Delete a sample by name, md5, or sha256")

  (options, args) = parser.parse_args()

  print "Args: %s" % args
  print "Options: %s" % options

  #Uncomment to enforce at least one final argument
  #if len(args) != 1:
      #parser.error("You didn't specify a target path.")
      #return False

  if options.ADD:
    print "> Add called with %s." % (options.ADD)
  #else:
    #print "Foo Dest: Blank"

  if options.FIND:
    print "> Find called with %s." % (options.FIND)
  #else:
    #print "Bar Dest: Blank"

  if options.RECENT:
    print "> Recent called with %s" % (options.RECENT)

  if options.DELETE:
    print "> Delete called with %s" % (options.DELETE)

  return True

if __name__ == "__main__":
  try:
      main()
  except KeyboardInterrupt:
      print "User aborted."
  except SystemExit:
      pass
  except:
      #systemexit
      pass
